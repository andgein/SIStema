# -*- coding: utf-8 -*-
# Generated by Django 1.10.5 on 2017-03-10 18:31
from __future__ import unicode_literals

from django.apps import apps as global_apps
from django.db import migrations

import sys
import datetime


def import_class(full_class_name):
    import importlib
    (module_name, class_name) = full_class_name.rsplit('.', 1)
    module = importlib.import_module(module_name)
    return getattr(module, class_name)


class EnrolledUserProfileGenerator(object):
    UserModel = None
    UserProfileModel = None

    User = None
    UserProfile = None
    EntranceStatus = None
    Questionnaire = None
    QuestionnaireAnswer = None
    ChoiceQuestionnaireQuestion = None
    ChoiceQuestionnaireQuestionVariant = None

    _variants = {}

    _created_profiles = 0
    _already_created_profiles = 0

    def generate_all(self, apps, schema_editor):
        if not global_apps.is_installed('questionnaire'):
            return
        if not global_apps.is_installed('modules.entrance'):
            return

        self.UserModel = apps.get_model('users', 'User')
        self.UserProfileModel = apps.get_model('users', 'UserProfile')

        self.User = import_class('users.models.User')
        self.UserProfile = import_class('users.models.UserProfile')
        self.EntranceStatus = import_class('modules.entrance.models.main.EntranceStatus')
        self.Questionnaire = import_class('questionnaire.models.Questionnaire')
        self.QuestionnaireAnswer = import_class('questionnaire.models.QuestionnaireAnswer')
        self.ChoiceQuestionnaireQuestion = import_class('questionnaire.models.ChoiceQuestionnaireQuestion')
        self.ChoiceQuestionnaireQuestionVariant = import_class('questionnaire.models.ChoiceQuestionnaireQuestionVariant')

        questionnaire_about = self.Questionnaire.objects.filter(short_name='about').first()
        if not questionnaire_about:
            sys.stderr.write("Questionnaire with short_name 'about' not found\n")
            return

        absent_users_count = 0
        for entrance_status in self.EntranceStatus.objects.filter(status=self.EntranceStatus.Status.ENROLLED).all():
            user = entrance_status.user
            if not user.is_active:
                raise Exception('Enrolled user(%d %s) was deactivated by some reason' % (user.id, str(user)))
            user_model = self.UserModel.objects.filter(id=user.id).first()
            if self.UserProfileModel.objects.filter(user=user_model).exists():
                self._already_created_profiles += 1
                continue

            school = entrance_status.school

            questionnaire_enrollee = self._get_school_questionnaire(school, 'enrollee', user)
            questionnaire_enrolled = self._get_school_questionnaire(school, 'enrolled', user)
            if not questionnaire_enrollee or not questionnaire_enrolled:
                absent_users_count += 1
                continue
            answers_about = self._get_all_answers(questionnaire_about, user)
            answers_enrollee = self._get_all_answers(questionnaire_enrollee, user)
            answers_enrolled = self._get_all_answers(questionnaire_enrolled, user)

            # sys.stderr.write('user %d %s\n' % (user.id, str(user)))
            user_profile = self.UserProfileModel(user=user_model)
            user_profile.first_name = self._get_answer(answers_enrolled, 'first_name')
            user_profile.middle_name = self._get_answer(answers_enrolled, 'middle_name')
            user_profile.last_name = self._get_answer(answers_enrolled, 'last_name')
            user_profile.sex = self._get_choice_answer(answers_about, 'sex', self.UserProfile.Sex)
            user_profile.birth_date = self._get_date_answer(answers_enrolled, 'birth_date')
            user_profile.zero_class_year = self._get_zero_class_year(school, answers_enrollee, user)
            user_profile.region = self._get_answer(answers_about, 'region')
            user_profile.city = self._get_answer(answers_about, 'city')
            user_profile.school_name = self._get_answer(answers_about, 'school')
            user_profile.phone = self._get_answer(answers_about, 'phone')
            user_profile.citizenship = self._get_choice_answer(answers_enrolled, 'citizenship',
                                                               self.UserProfile.Citizenship)
            user_profile.citizenship_other = self._get_answer(answers_enrolled, 'citizenship_other')
            user_profile.document_type = self._get_choice_answer(answers_enrolled, 'document_type',
                                                                 self.UserProfile.DocumentType)
            user_profile.document_number = self._get_answer(answers_enrolled, 'document_number')
            user_profile.insurance_number = self._get_answer(answers_enrolled, 'insurance_number')

            if user_profile.citizenship != self.UserProfile.Citizenship.OTHER and user_profile.citizenship_other:
                sys.stderr.write("drop citizenship_other '%s' for user(%d %s) with citizenship %d \n"
                                 % (user_profile.citizenship_other, user.id, str(user), user_profile.citizenship))
                user_profile.citizenship_other = ''

            user_profile.save()
            self._created_profiles += 1

        sys.stderr.write("%d users was enrolled, but they didn't approve participation\n" % absent_users_count)
        sys.stderr.write('%d new profiles have been generated\n' % self._created_profiles)
        sys.stderr.write('%d profiles have already been generated\n' % self._already_created_profiles)

    def _get_school_questionnaire(self, school, short_name, user):
        questionnaire = self.Questionnaire.objects.filter(short_name=short_name, school=school).first()
        if not questionnaire:
            # sys.stderr.write("Questionnaire with short_name '%s' for school %s not found\n" % (short_name, str(school)))
            return None
        if not questionnaire.is_filled_by(user):
            # sys.stderr.write("User(%d %s) didn't fill %s questionnaire\n" % (user.id, str(user), short_name))
            return None
        return questionnaire

    def _get_all_answers(self, questionnaire, user):
        answers = self.QuestionnaireAnswer.objects.filter(user=user, questionnaire=questionnaire).all()
        return {x.question_short_name: x for x in answers}

    @classmethod
    def _get_answer(cls, answers, question_short_name):
        if question_short_name in answers:
            return answers[question_short_name].answer
        return None

    @classmethod
    def _get_date_answer(cls, answers, question_short_name):
        answer = cls._get_answer(answers, question_short_name)
        if answer is None:
            return None
        return datetime.datetime.strptime(answer, '%d.%m.%Y').date()

    def _get_zero_class_year(self, school, answers, user):
        answer = EnrolledUserProfileGenerator._get_answer(answers, 'class')
        if answer is None:
            return None
        try:
            current_class = int(answer)
        except ValueError:
            sys.stderr.write("user(%d %s) Can not parse class '%s'\n" % (user.id, str(user), answer))
            return None
        school_date = datetime.date(year=int(school.year), month=4, day=1)
        temp_profile = self.UserProfile()
        temp_profile.set_class(current_class, school_date)
        return temp_profile.get_zero_class_year()

    def _get_choice_answer(self, answers, question_short_name, choice_class):
        answer = self._get_answer(answers, question_short_name)
        if answer is None:
            return None
        variant_id = int(answer)
        if question_short_name not in self._variants:
            self._variants[question_short_name] = {
                variant.id: variant.text
                for variant in self.ChoiceQuestionnaireQuestionVariant.objects.filter(
                    question__abstractquestionnairequestion_ptr__short_name=question_short_name
                ).all()}
        variant_text = self._variants[question_short_name][variant_id]
        for choice in choice_class.choices:
            if choice[1] == variant_text:
                return choice[0]
        raise Exception("Unexpected variant text '%s'" % variant_text)

    @classmethod
    def as_callable(cls):
        def func(*args, **kwargs):
            cls().generate_all(*args, **kwargs)

        return func


class Migration(migrations.Migration):
    operations = [
        migrations.RunPython(EnrolledUserProfileGenerator.as_callable(), migrations.RunPython.noop),
    ]

    dependencies = [
        ('users', '0009_convert_social_accounts'),
    ]

    if global_apps.is_installed('questionnaire'):
        dependencies.append(('questionnaire', '0015_auto_20160725_1510'))

    if global_apps.is_installed('modules.entrance'):
        dependencies.append(('entrance', '0024_entranceexamtask_order'))
